---
title: "Machine learning in R part 1: regression"
author: "Jeff Oliver"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document: default
  pdf_document:
    latex_engine: xelatex
urlcolor: blue
---

An introduction to the concept of machine learning, with a worked application 
showing model comparison and evaluation of model performance.

#### Learning objectives
1. Explain the difference between machine learning and inferential statistics
2. Load tabular data into R
3. Build a predictive model and evaluate model performance
4. Split data into training and testing sets
5. Apply iteration to model evaluation and model selection

Machine learning has been all the rage, but there remains a lot of mystery 
about what machine learning really _is_. In this workshop, we will work through 
an example of how we use machine learning to make predictions and how to assess 
how good those predictions really are. The material is designed for people who 
have little to no experience with machine learning.

#### The setting

So. Taylor Swift. Music phenom. The obvious focus of our machine learning 
lesson. Let us imagine we are in Taylor's position of releasing a new album. 
Before we release the album, we want to start it off by dropping a single. Not 
just any single, but one that will race up the charts to build the anticipation 
for the album. This leads to our goal: build a machine learning algorithm, 
based on Taylor Swift's released songs, that will predict the billboard 
position of a new song so Taylor can choose the first single from the album to 
release.

***

## Getting started

### Workspace organization

First we need to setup our development environment. Open RStudio and create a 
new project via:

+ File > New Project...
+ Select 'New Directory'
+ For the Project Type select 'New Project'
+ For Directory name, call it something like "ml-regression" (without the quotes)
+ For the subdirectory, select somewhere you will remember (like "My Documents" 
or "Desktop")

We need to create two folders: 'data' will store the data we will be analyzing, 
and 'output' will store the results of our analyses. In the RStudio console:

```{r workspace-setup, eval = FALSE}
dir.create(path = "data")
dir.create(path = "output")
```

It is good practice to keep input (i.e. the data) and output separate. 
Furthermore, any work that ends up in the **output** folder should be completely
disposable. That is, the combination of data and the code we write should allow 
us (or anyone else, for that matter) to reproduce any output.

### Install additional R packages

There are _two_ additional R packages that will need to be installed:

+ dplyr
+ randomforest

To install these, run:

```{r install-libraries, eval = FALSE}
install.packages("dplyr")
install.packages("randomforest")
```

### Example data

The data we are using comes from two sources:

1. We have a variety of song characteristics from W. Jake Thompson, who 
assembled the data from Genius and the Spotify API. These data were initially 
retrieved from the Tidy Tuesday website for [October 17, 2023](https://github.com/rfordatascience/tidytuesday/blob/master/data/2023/2023-10-17). 
The song characteristics include measurements of loudness, tempo, and 
acousticness.

2. We also have the highest position for Taylor Swift's released songs. These 
come from a [GitHub project](https://github.com/scharfsteina/BigDataFinalProject) 
by Ava Scharfstein and Aimi Wen. The authors used Python webscraping tools to 
retrieve Billboard chart positions for a majority of Taylor Swift songs. They 
did a bunch of neat analyses and you can check them out on the 
[Project Webpage](https://medium.com/@aimiwen33/exploring-taylor-swifts-music-2bce11a7aab2).

Note that I went ahead and joined these two datasets together. If you want to 
learn more about that process, see the [Bonus Track](#Bonus-Track-Data-Wrangling)
section at the end of this lesson.

The data are available at [BITLY LINK](BITLY LINK) and [learn-rlink](learn-rlink) 
(the former just re-directs to the latter). Use a web browser to navigate to 
one of those URLs and download the file as a plain text or CSV file (on some 
systems, you can save as an Excel CSV, which is fine, too). Make sure after you 
download the file that you move it into the "data" folder you created at the 
beginning of this lesson.

***

## Machine learning in a nutshell

In this lesson, we are going to run through an relatively minimal example of 
machine learning. The term "machine learning" gets thrown around a lot, often 
with little explanation, so we will start with a _very_ brief explanation. The 
big difference between "traditional" statistics and machine learning is the 
goal of each approach (aside: the modifier "traditional" is in no way meant to 
imply a lesser status or utility of statistics - I just could not come up with 
a better term). That is, the statistics we learned in class are generally 
focused on making inferences about how the world works, i.e. how does $X$ 
affect $Y$? In contrast, machine learning is less concerned with the details of 
how $X$ and $Y$ are related, but rather focused on using $X$ to make accurate 
predictions of $Y$. If we consider this in a linear regression framework, 
statistics cares about getting accurate values for the beta hats 
($\hat{\beta}$) on the right-hand side of the equation, while machine learning 
cares about being able to make accurate predictions for the Y hats ($\hat{Y}$) 
on the left-hand side of the equation:

$$
\hat{Y} = \hat{\beta}_0 + \hat{\beta}_1 X_1 
$$

***

```{r dev-block}
# Place for experimentation; replace later
# Merging Taylor Swift data

library(dplyr)
library(randomForest)

# Chart data for Beyonce (& TS) available at 
# https://github.com/rfordatascience/tidytuesday/tree/master/data/2020/2020-09-29
# How do we get song characteristics? Might look at how it was done for TS:
# https://github.com/wjakethompson/taylor

# Song characteristics
# https://github.com/rfordatascience/tidytuesday/blob/master/data/2023/2023-10-17/taylor_all_songs.csv
# Billboard performance
# https://github.com/scharfsteina/BigDataFinalProject/blob/main/data/billboard.csv


## TOPIC FIVE (data wrangling)

songs <- read.csv(file = "https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-10-17/taylor_all_songs.csv")
scores <- read.csv(file = "https://raw.githubusercontent.com/scharfsteina/BigDataFinalProject/main/data/billboard.csv")
colnames(scores)[1] <- "id"

# songs <- read.csv(file = "~/Desktop/taylor_all_songs.csv")
# scores <- read.csv(file = "~/Desktop/billboard.csv")

songs$track_name <- tolower(songs$track_name)

combined <- scores %>%
  left_join(songs, by = join_by(song == track_name))

# We want to predict peak_position
# Predictors (aka "features")
# danceability energy loudness speechiness acousticness instrumentalness liveness valence tempo explicit mode_name

model_data <- combined %>%
  select(peak_position, danceability, energy, loudness, speechiness, 
         acousticness, instrumentalness, liveness, valence, tempo, explicit, 
         mode_name) %>% 
  na.omit()

# Run a linear model with all predictors
linear_model <- lm(peak_position ~ ., data = model_data)

# Run a glm with all predictors and poisson model
gl_model <- glm(peak_position ~ ., data = model_data, family = "poisson")

# Run a random forest model with all predictors
rf_model <- randomForest(peak_position ~ ., data = model_data)

## TOPIC TWO

# Comparing model performance

# Predict song's peak position based on linear model
linear_prediction <- predict(linear_model, newdata = model_data)

# Predict song's peak position based on glm
glm_prediction <- predict(gl_model, newdata = model_data, type = "response")

# Predict song's peak position based on random forest model
rf_prediction <- predict(rf_model, newdata = model_data)

# Calculate RMSE for each model: square root of the mean squared error
linear_mse <- mean((model_data$peak_position - linear_prediction)^2)
linear_rmse <- sqrt(linear_mse)

glm_mse <- mean((model_data$peak_position - glm_prediction)^2)
glm_rmse <- sqrt(glm_mse)

rf_mse <- mean((model_data$peak_position - rf_prediction)^2)
rf_rmse <- sqrt(rf_mse)

cat("Linear model RMSE: ", linear_rmse, "\n")
cat("GLM RMSE: ", glm_rmse)
cat("Random forest RMSE: ", rf_rmse)

## TOPIC THREE

# Splitting data into testing and training

# Create fold vector
fold <- rep_len(x = 1:5, length.out = nrow(model_data))

# One test/train
training <- model_data %>%
  filter(fold != 1)
testing <- model_data %>%
  filter(fold == 1)

# Use training data only to build & evaluate model

# Run a linear model with all predictors
linear_model <- lm(peak_position ~ ., data = training)

# Run a glm with all predictors and poisson model
gl_model <- glm(peak_position ~ ., data = training, family = "poisson")

# Run a random forest model with all predictors
rf_model <- randomForest(peak_position ~ ., data = training)

# Predict song's peak position based on linear model for TESTING data
linear_prediction <- predict(linear_model, newdata = testing)

# Predict song's peak position based on glm for TESTING data
glm_prediction <- predict(gl_model, newdata = testing, type = "response")

# Predict song's peak position based on random forest model for TESTING data
rf_prediction <- predict(rf_model, newdata = testing)

# Calculate RMSE for each model: square root of the mean squared error
linear_mse <- mean((testing$peak_position - linear_prediction)^2)
linear_rmse <- sqrt(linear_mse)

glm_mse <- mean((testing$peak_position - glm_prediction)^2)
glm_rmse <- sqrt(glm_mse)

rf_mse <- mean((testing$peak_position - rf_prediction)^2)
rf_rmse <- sqrt(rf_mse)

cat("Linear model RMSE: ", linear_rmse, "\n")
cat("GLM RMSE: ", glm_rmse, "\n")
cat("Random forest RMSE: ", rf_rmse)

# Note both got worse, but RF got considerably worse (almost double RMSE)

# Now need to do this for each of the folds
# Data frame to hold results
ml_results <- data.frame(fold = 1:5,
                         linear_rmse = NA,
                         glm_rmse = NA,
                         rf_rmse = NA)
for (f in 1:5) {
  # One test/train
  training <- model_data %>%
    filter(fold != f)
  testing <- model_data %>%
    filter(fold == f)
  
  # Use training data only to build & evaluate model
  
  # Run a linear model with all predictors
  linear_model <- lm(peak_position ~ ., data = training)
  
  # Run a glm with all predictors and poisson model
  gl_model <- glm(peak_position ~ ., data = training, family = "poisson")
  
  # Run a random forest model with all predictors
  rf_model <- randomForest(peak_position ~ ., data = training)
  
  # Predict song's peak position based on linear model for TESTING data
  linear_prediction <- predict(linear_model, newdata = testing)
  
  # Predict song's peak position based on glm for TESTING data
  glm_prediction <- predict(gl_model, newdata = testing, type = "response")
  
  # Predict song's peak position based on random forest model for TESTING data
  rf_prediction <- predict(rf_model, newdata = testing)
  
  # Calculate RMSE for each model: square root of the mean squared error
  linear_mse <- mean((testing$peak_position - linear_prediction)^2)
  linear_rmse <- sqrt(linear_mse)

  glm_mse <- mean((testing$peak_position - glm_prediction)^2)
  glm_rmse <- sqrt(glm_mse)
  
  rf_mse <- mean((testing$peak_position - rf_prediction)^2)
  rf_rmse <- sqrt(rf_mse)
  
  ml_results$linear_rmse[f] <- linear_rmse
  ml_results$glm_rmse[f] <- glm_rmse
  ml_results$rf_rmse[f] <- rf_rmse
}

ml_results

# Calculate means for each
linear_mean <- mean(ml_results$linear_rmse)
glm_mean <- mean(ml_results$glm_rmse)
rf_mean <- mean(ml_results$rf_rmse)

cat("Linear model mean RMSE: ", linear_mean, "\n")
cat("GLM mean RMSE: ", glm_mean, "\n")
cat("Random forest mean RMSE: ", rf_mean, "\n")

# Make a plot?


```

## [TOPIC ONE]

Starting the script
Load the libraries

Running the two models


Vanilla linear regression
Regression trees

***

## [TOPIC TWO]

Comparing the two models via RMSE (no training/testing split)

***

## [TOPIC THREE]

Training & testing split, a little bit why, mostly how
Comparing the two models via RMSE means

***

## [TOPIC FOUR]

Next steps

1. Variable (feature) selection
2. Poisson regression instead of vanilla linear regression
3. Poisson model for random forest

***

## Bonus Track: Data Wrangling

The data we used for this lesson did not come in the form that we used them. 
That is, there were several steps that needed to happen _before_ we started 
using the data in the models. These steps were:

1. Downloading the original song data
2. Downloading the original score data for each song
3. Combining the two above data sources
4. Removing unnecessary columns from data
5. Removing any rows that are missing data

The section below illustrates these four steps. Note the cleaned data are all 
available (**TODO**: add a link to data), so you do not need to run the code below in order to do the machine 
learning parts of the lesson. But for those who are curious, the code below 
highlights that most machine learning applications require substantial curation 
of data sources before any models are built.

Just in case you haven't already loaded the dplyr library, we do so now.
```{r prep-libraries, eval = FALSE}
library(dplyr)
```

```{r data-download}
# Location of song data on Tidy Tuesday site 2023-10-17
song_url <- "https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-10-17/taylor_all_songs.csv"
# Location of Billboard chart data
scores_url <- "https://raw.githubusercontent.com/scharfsteina/BigDataFinalProject/main/data/billboard.csv"

# Download both datasets
songs <- read.csv(file = song_url)
scores <- read.csv(file = scores_url)
```

We can look at the column names for both datasets as a reality check. We will 
need to join the data sets together, so they will need to have one column with 
the same information. The column _names_ do not necessarily have to match, but 
the data do. The `songs` data has the following columns:

```{r songs-columns}
colnames(songs)
```

Since we are doing an analysis on the level of the song (remember, we want to 
predict an individual song's highest spot on the Billboard chart), the fifth 
column, `r colnames(songs)[5]`, looks like the one we will use to join it with 
the `scores` data. Speaking of the `scores` data, it has the following columns:

```{r scores-columns}
colnames(scores)
```

There are two things of note:

1. There is no `track_name` column in the `scores` data, but there is a `song` 
column.
2. The first column is just called `X`, which is  not very informative.

Let us look at the first six rows of the `scores` data:

```{r scores-head}
head(scores)
```

So the `song` column looks like it has the information wee need to join with 
the `songs` data. The `X` column just looks like an identifier, so we can 
rename the column with a more informative name.

```{r rename-x}
# Rename first column of scores data from "X" to "id"
colnames(scores)[1] <- "id"
```

Before we join the data together it is worthwhile glancing at the values in the 
`track_name` column of the `songs` data. Here we will just look at the first 
ten values:

```{r songs-tracks}
songs$track_name[1:10]
```

And compare that to the first ten songs in the `scores` data:

```{r scores-songs}
scores$song[1:10]
```

Now the song names in the two datasets are in different orders, but that is not 
a concern, because we will use functions in R that know how to line the rows up 
correctly. However, note that the song names in the `songs` data have capital 
letters (it uses title case), while song names in the `scores` data are all 
lower case letters. If we leave the data like this, R will not be able to join 
the data together the right way. That is, if we tried to join the datasets 
together as is, R would think that "Shake It Off" and "shake it off" are 
different songs. _We_ know that these are the same song, but we need to change 
the data so R also sees them as the same song. The easiest way to do this is to 
change _all_ the letters in song names to lower case. It looks like the song 
names in the `scores` data are already lower case, but we can do the 
transformation on both datasets, just to be sure.

```{r songs-to-lower}
# Change song names to lower case
songs$track_name <- tolower(songs$track_name)
scores$song <- tolower(scores$song)
```

One final check and we can see that both datasets now have song names that are 
all lower case letters:

```{r songs-check}
songs$track_name[1:10]
```

```{r scores-check}
scores$song[1:10]
```

We're almost there. For some reason, the song "I Knew You Were Trouble" 
includes a period in the `scores` dataset, but does not in the `songs` dataset. 
We need to make sure these song names match _exactly_ or R will consider them 
different songs. For this case, we will just replace the version in the 
`scores` dataset so that it does not include a period.

```{r scores-trouble}
scores$song <- gsub(pattern = "i knew you were trouble.",
                    replacement = "i knew you were trouble",
                    x = scores$song,
                    fixed = TRUE)
```

And looking at the first few songs in the `scores` dataset, we see that one 
song has been updated:

```{r scores-check-2}
scores$song[1:10]
```

You can also check for any additional differences between the datasets by using 
base R's `setdiff()` function or dplyr's version of `setdiff()`. For now we 
will skip this step, the set operations are useful for comparing things before 
merges and joins.

We are now ready to join the song data with the scores data. We can do this 
with functions from dplyr, including the pipe, `%>%` and the `left_join()` 
function. We can join the datasets by telling the `left_join()` functions which 
columns to use when merging the datasets:

```{r join-data}
combined <- left_join(scores, songs, by = join_by(song == track_name))
```

Here we are telling R to add rows together from the "left" dataset (`scores` in 
our case) to the "right" dataset (`songs`). We tell it to use the "song" column 
of the "left" dataset to find the corresponding row in the "track_name" column 
of the "right" dataset. The distinction of "left" and "right" really just 
relies on where they appear in the `inner_join()` function: `scores` is on the 
left, `songs` is on the right.

These data now have all the columns from `songs` and all the columns from 
`scores` (a total of `r length(combined$song)` columns). For the purposes of 
this lesson, we only need (1) the highest position on the charts the song 
achieved (that is, the thing we are trying to predict) and (2) song 
characteristics (the things we use to make predictions, AKA features), such as 
how loud and how danceable a song is (aren't they _all_ danceable?). So the 
last steps are to select only those columns of interest, drop any remaining 
rows that are missing data, and write the data to a CSV file.

```{r}
# We want to predict peak_position
# Predictors (aka "features"):
# danceability energy loudness speechiness acousticness instrumentalness 
# liveness valence tempo explicit mode_name
model_data <- combined %>%
  select(peak_position, danceability, energy, loudness, speechiness, 
         acousticness, instrumentalness, liveness, valence, tempo, explicit, 
         mode_name) %>% 
  na.omit() # Drop any rows missing data

write.csv(file = "data/swift-data.csv",
          x = model_data,
          row.names = FALSE)
```

***

## Additional resources

+ An extremely useful resource is [An Introduction to Statistical Learning with Applications in R](https://arizona-primo.hosted.exlibrisgroup.com/permalink/f/evot53/01UA_ALMA51605092790003843), 
by Gareth James and colleagues. This book provides an accessible introduction 
to several machine learning approaches, including regression and classification
techniques, along with _a lot_ of worked examples and R code.
+ [resource two](url-two)
+ A [PDF version](https://jcoliver.github.io/learn-r/lesson-name.pdf) of this lesson

***

<a href="index.html">Back to learn-r main page</a>
  
Questions?  e-mail me at <a href="mailto:jcoliver@arizona.edu">jcoliver@arizona.edu</a>.